<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <style>
      html,
      body {
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
      }
      #cnv {
        width: 100%;
        height: 100%;
      }
    </style>
    <title>Document</title>
  </head>
  <body>
    <canvas id="cnv"></canvas>
  </body>
  <script>
    // Logic

    const operations = [];
    const edges = [];
    let counter = 0;

    const addOperation = (type, inputNumber, outputNumber, x, y) => {
      const op = {
        id: counter++,
        type,
        inputNumber,
        outputNumber,
        x,
        y,
      };
      operations.push(op);
      return op;
    };

    const listNodes = (op) => {
      let nodes = [];
      for (let i = 0; i < op.inputNumber; i++) {
        nodes.push({
          operationId: op.id,
          type: "input",
          number: i,
        });
      }
      for (let i = 0; i < op.outputNumber; i++) {
        nodes.push({
          operationId: op.id,
          type: "output",
          number: i,
        });
      }
      return nodes;
    };

    const hashNode = (node) => {
      return `${node.operationId}-${node.type}-${node.number}`;
    };

    const isConnectable = (from, to) => {
      if (from.type === to.type) return false;
      if (from.type === "input") [from, to] = [to, from];

      const toHash = hashNode(to);
      for (const [_, to] of edges) {
        if (hashNode(to) === toHash) return false;
      }

      return true;
    };

    const connect = (from, to) => {
      if (!isConnectable(from, to)) return;
      edges.push([from, to]);
    };

    const findOperation = (id) => {
      for (const op of operations) {
        if (op.id === id) return op;
      }
      throw Error("Operation not found");
    };

    const getObjectType = (object) => {
      if ("id" in object) return "operation";
      if ("operationId" in object) return "node";
      throw Error("Unknown object type");
    };

    // Graphics logic layer

    const OP_WIDTH = 100;
    const NODE_GAP = 20;
    const NEAR_THRESHOLD = 10;

    const flippedOperations = {};
    let selectedOperation = null;
    let selectedNode = null;

    let mouseX = 0;
    let mouseY = 0;

    const getOpRect = (op) => {
      const n = Math.max(op.inputNumber, op.outputNumber);
      const height = (n - 1) * NODE_GAP;
      return {
        x: op.x,
        y: op.y,
        width: OP_WIDTH,
        height,
      };
    };

    const flipOperation = (op) => {
      flippedOperations[op.id] = !flippedOperations[op.id];
    };

    const isNodeFlipped = (node) => {
      return !!flippedOperations[node.operationId];
    };

    const getNodeY = (node) => {
      const op = findOperation(node.operationId);
      const m = Math.max(op.inputNumber, op.outputNumber);
      const nodes = node.type === "input" ? op.inputNumber : op.outputNumber;
      const y = op.y + (node.number + (m - nodes) / 2) * NODE_GAP;
      return y;
    };

    const getNodeX = (node) => {
      if (!isNodeFlipped(node)) {
        if (node.type === "input") {
          return findOperation(node.operationId).x;
        } else {
          return findOperation(node.operationId).x + OP_WIDTH;
        }
      } else {
        if (node.type === "input") {
          return findOperation(node.operationId).x + OP_WIDTH;
        } else {
          return findOperation(node.operationId).x;
        }
      }
    };

    const getNodeDirection = (node) => {
      if (!isNodeFlipped(node)) {
        if (node.type === "input") {
          return -1;
        } else {
          return 1;
        }
      } else {
        if (node.type === "input") {
          return 1;
        } else {
          return -1;
        }
      }
    };

    const getNodePosition = (node) => {
      const op = findOperation(node.operationId);
      const m = Math.max(op.inputNumber, op.outputNumber);
      const x = getNodeX(node);
      const y = getNodeY(node);
      return { x, y };
    };

    const setMousePosition = (x, y) => {
      mouseX = x;
      mouseY = y;

      if (selectedOperation) {
        selectedOperation.x = mouseX;
        selectedOperation.y = mouseY;
      }
    };

    const getNearestObject = () => {
      let nearest = null;
      let minDistance = NEAR_THRESHOLD;

      for (const op of operations) {
        for (const node of listNodes(op)) {
          const pos = getNodePosition(node);
          const distance = Math.sqrt(
            (pos.x - mouseX) ** 2 + (pos.y - mouseY) ** 2
          );
          if (distance < minDistance) {
            minDistance = distance;
            nearest = node;
          }
        }
      }

      if (nearest) return nearest;

      for (const op of operations) {
        const rect = getOpRect(op);
        if (mouseX < rect.x || mouseX > rect.x + rect.width) continue;
        if (mouseY < rect.y || mouseY > rect.y + rect.height) continue;
        return op;
      }
    };

    const click = () => {
      const near = getNearestObject();

      if (!selectedOperation && !selectedNode && !near) {
        // Create new operation
        const op = addOperation("add", 2, 1, mouseX, mouseY);
        selectedOperation = op;
      } else if (selectedOperation) {
        // Placing operation
        selectedOperation = null;
      } else if (selectedNode) {
        // Connecting nodes
        if (near && getObjectType(near) === "node") {
          connect(selectedNode, near);
        }
        selectedNode = null;
      } else {
        // Selecting operation or node
        if (getObjectType(near) === "operation") {
          selectedOperation = near;
        } else {
          selectedNode = near;
        }
      }
    };

    // Implementation layer

    const cnv = document.getElementById("cnv");
    const ctx = cnv.getContext("2d");
    cnv.width = window.innerWidth;
    cnv.height = window.innerHeight;

    cnv.addEventListener("mousemove", (e) => {
      setMousePosition(e.clientX, e.clientY);
    });

    cnv.addEventListener("click", click);

    document.body.addEventListener("keydown", (e) => {
      // Flip when space is pressed
      if (e.key !== " ") return;
      if (!selectedOperation) return;
      flipOperation(selectedOperation);
    });

    const getCurveFunction = (x1, x2, x_1, x_2) => {
      const a = x_1 + x_2 + 2 * x1 - 2 * x2;
      const b = -2 * x_1 - x_2 - 3 * x1 + 3 * x2;
      const c = x_1;
      const d = x1;
      return (t) => a * t ** 3 + b * t ** 2 + c * t + d;
    };

    const getEdgeCurve = (x1, y1, x2, y2, dl = 1, dr = 1, k = 100) => {
      const points = [];
      const n = 100;
      const _k = Math.pow(Math.abs(x1 - x2), 1 / 3) * k;
      const fx = getCurveFunction(x1, x2, _k * dl, -_k * dr);
      const fy = getCurveFunction(y1, y2, 0, 0);
      for (let i = 0; i <= n; i++) {
        const t = i / n;
        const x = fx(t);
        const y = fy(t);
        points.push({ x, y });
      }
      return points;
    };

    const render = () => {
      ctx.clearRect(0, 0, cnv.width, cnv.height);

      let cursorX = mouseX;
      let cursorY = mouseY;
      const nearest = getNearestObject();
      if (nearest) {
        if (getObjectType(nearest) === "operation") {
          const rect = getOpRect(nearest);
          cursorX = rect.x + rect.width / 2;
          cursorY = rect.y + rect.height / 2;
        } else {
          const pos = getNodePosition(nearest);
          cursorX = pos.x;
          cursorY = pos.y;
        }
      }
      ctx.beginPath();
      ctx.arc(cursorX, cursorY, 5, 0, Math.PI * 2);
      ctx.stroke();

      for (const op of operations) {
        const rect = getOpRect(op);
        ctx.strokeRect(rect.x, rect.y, rect.width, rect.height);
        for (const node of listNodes(op)) {
          const pos = getNodePosition(node);
          ctx.beginPath();
          ctx.arc(pos.x, pos.y, 5, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      for (const [from, to] of edges) {
        const p1 = getNodePosition(from);
        const p2 = getNodePosition(to);
        const dir1 = getNodeDirection(from);
        const dir2 = getNodeDirection(to);

        const curve = getEdgeCurve(p1.x, p1.y, p2.x, p2.y, dir1, dir2, 100);
        ctx.beginPath();
        ctx.moveTo(curve[0].x, curve[0].y);
        for (const point of curve) {
          ctx.lineTo(point.x, point.y);
        }
        ctx.stroke();
      }

      if (selectedOperation) {
        const rect = getOpRect(selectedOperation);
        ctx.strokeRect(rect.x, rect.y, rect.width, rect.height);
      }

      if (selectedNode) {
        const pos = getNodePosition(selectedNode);
        const dir = getNodeDirection(selectedNode);
        let dir2 = 1;
        if (nearest && getObjectType(nearest) === "node") {
          dir2 = getNodeDirection(nearest);
        } else {
          dir2 = Math.sign(pos.x - cursorX);
        }

        const curve = getEdgeCurve(pos.x, pos.y, cursorX, cursorY, dir, dir2);
        ctx.beginPath();
        ctx.moveTo(curve[0].x, curve[0].y);
        for (const point of curve) {
          ctx.lineTo(point.x, point.y);
        }
        ctx.stroke();
      }
    };

    const loop = () => {
      render();
      requestAnimationFrame(loop);
    };

    loop();
  </script>
</html>
